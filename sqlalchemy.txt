**READ HANDOUT.PDF**
psycopg2 api flow :
connection = psycopg2.connect("user","pass","dbname")
cur = connection.cursor()
cur.execute('sql query')
data = cur.fetchone()[0]
cur.close() # close cursor before next sql query
connection.commit()

*Bound parameters : emp_id is a bound parameter here and subsctituion is taen care by driver such as psycopg2
cur.execute("select * from emptable  where employee_id = %(emp_id)",{'emp_id':5})

* The first layer in SQlalchemy is called engine 

* engine = create_engine("sqlite:///some.db") # Create Engine with lazy initilization
engine = create_engine("postgres://simon:password@localhost/testdb") # Postgres initiliasation.
or if you wann use specific driver
engine = create_engine("postgres+psycopg2://simon:password@localhost/testdb") # Postgres initiliasation.

result = engine.execute('select name from emp where emp_id=%(emp_id)',emp_id=3) #returns a rowProxy object.
row = result.fetchone() # returns a tuple with values  which is a tuple which also acs like a dict and gives values based on key likes row['emp_id']

* results close automatically when all rows are exhausted, but we can also close explicitly useing result.close()

*result obejct can also be iterated upon instead os ufing fetchone
 result = engine.execute("select * from employee")
  for row in result:
...     print(row)

*result.fetchall() is the shortcut for producing the list of all rows
>>> result = engine.execute("select * from employee")
>>> print(result.fetchall())
[(1, u'ed'), (2, u'jack'), (3, u'fred')]


*The execute() method of Engine will *autocommit*  statements like INSERT UPDATE etc. by default.   
example insert command: engine.execute("insert into employee (emp_name) values (:emp_name)",emp_name="dilbert") 

We can control the scope of connection using connect().
>>> conn = engine.connect()
>>> result = conn.execute("select * from employee")
>>> result.fetchall()
>>> conn.close()


*to run several statements inside a transaction, Connection features a begin() method that returns a Transaction.
>>> conn = engine.connect()
>>> trans = conn.begin()
>>> conn.execute("insert into employee (emp_name) values (:emp_name)", emp_name="wendy")
>>> conn.execute("update employee_of_month set emp_name = :emp_name", emp_name="wendy")
>>> trans.commit()
>>> conn.close()

*Context manager used below to do the same transaction shit as above , beautifull
>>> with engine.begin() as conn:
...     conn.execute("insert into employee (emp_name) values (:emp_name)", emp_name="mary")
...     conn.execute("update employee_of_month set emp_name = :emp_name", emp_name="mary")

Engine Facts: Executing direcyly via the engins is called as connectionless execution as engine conencts and
disconnects for us. Using a connection object we can control the span on connnection in use.


**Schema and MetaData **
The structure of a relational schema is represented in Python  using MetaData, Table, and other objects.

from sqlalchemy import String MetaData,Integer,Column ,Table

>>> metadata = MetaData()
>>> user_table = Table('user', metadata,
...                Column('id', Integer, primary_key=True),
...                Column('name', String),
...                Column('fullname', String)
...              )

>>> user_table.name
'user'
In : user_table.c.name
Column('name', String(), table=<user>) # shows the details about columns
In : user_table.c.id
Column('id', Integer(), table=<user>, primary_key=True, nullable=False)

*Table and MetaData objects can be used to generate a schema  in a database.   
In : from sqlalchemy import create_engine
In : engine = create_engine("sqlite://")
In : metadata.create_all(engine)
CREATE TABLE user (
	id INTEGER NOT NULL, 
	name VARCHAR, 
	fullname VARCHAR, 
	PRIMARY KEY (id)
)


*Types are represented using objects such as String, Integer,     
 DateTime.  These objects can be specified as "class keywords",   
 or can be instantiated with arguments.                           

In : from sqlalchemy import String, Numeric, DateTime, Enum
In : fancy_table = Table('fancy', metadata,
...:                     Column('key', String(50), primary_key=True),
...:                     Column('timestamp', DateTime),
...:                     Column('amount', Numeric(10, 2)),		#
...:                     Column('type', Enum('a', 'b', 'c'))   #Check constraint
...:                 )
In : fancy_table.create(engine)


*Foreign Key
In : from sqlalchemy import ForeignKey
In : addresses_table = Table('address', metadata,
...:                     Column('id', Integer, primary_key=True),
...:                     Column('email_address', String(100), nullable=False),
...:                     Column('user_id', Integer, ForeignKey('user.id'))
...:                   )
In : addresses_table.create(engine)

Then emit metadata.create_all(), which will  emit CREATE TABLE for this table (it will skip those that already exist).

On the contrary we have metadata.drop_all() and tablname.drop() methods to drop the tables.dropa;l takes care of all constraints

*'reflection' refers to loading Table objects based on  reading from an existing database.   
In : metadata2 = MetaData()
In : user_reflected = Table('user', metadata2, autoload=True, autoload_with=engine)

*Information about a database at a more specific level is available  using the Inspector object.

In : from sqlalchemy import inspect
In : inspector = inspect(engine)
Helpful in things like below:
inspector.get_table_names()
inspector.get_columns('address')
inspector.get_foreign_keys('address')



**SQL EXPRESSIONS***


In : user_table.c.username == 'ed'
<sqlalchemy.sql.elements.BinaryExpression object at 0x9d9c66c>
They become SQL when evaluated as a string as shown below
In : str(user_table.c.username == 'ed')
'"user".username = :username_1

 OR and AND are available with |, &, or or_() and and_()          |

In : from sqlalchemy import and_, or_

In : print(
...:     and_(
...:         user_table.c.fullname == 'ed jones',
...:             or_(
...:                 user_table.c.username == 'ed',
...:                 user_table.c.username == 'jack'
...:             )
...:         )
...:     )
"user".fullname = :fullname_1 AND ("user".username = :username_1 OR "user".username = :username_2)


*Using an  IN operator
In : print(user_table.c.username.in_(["wendy", "mary", "ed"]))
"user".username IN (:username_1, :username_2, :username_3)

*In : expression = user_table.c.username == 'ed'
In : print(expression)
"user".username = :username_1

The values of our "bound" parameters are still there, however,   stored away within a structure called the "compiled" object      
In : compiled = expression.compile()
In : compiled.params
{u'username_1': 'ed'}

In : expression.operator
<built-in function eq>
In : expression.left
Column('username', String(length=50), table=<user>)
In : expression.right
BindParameter('%(165268972 username)s', 'ed', type_=String(length=50))


*The "bound" parameters are extracted when we execute()           

*Select Statement
In : engine.execute(
...:         user_table.select().where(user_table.c.username == 'ed')
...:     )

Other way of select :
In : from sqlalchemy import select
In : select_stmt = select([user_table.c.username, user_table.c.fullname]).\
...:             where(user_table.c.username == 'ed')
In : result = conn.execute(select_stmt)
In : for row in result:
...:     print(row)

*select all columns from a table
In : select_stmt = select([user_table])
In : conn.execute(select_stmt).fetchall()

* specify a WHERE clause                                           
In : select_stmt = select([user_table]).\
...:                     where(
...:                         or_(
...:                             user_table.c.username == 'ed',
...:                             user_table.c.username == 'wendy'
...:                         )
...:                     )
In : conn.execute(select_stmt).fetchall()

*specify multiple WHERE, will be joined by AND #This is called method chaining 
In : select_stmt = select([user_table]).\
...:                     where(user_table.c.username == 'ed').\
...:                     where(user_table.c.fullname == 'ed jones')
In : conn.execute(select_stmt).fetchall()




String or SQl representation
In : print user_table.select()
SELECT "user".id, "user".username, "user".fullname FROM "user"
In : print user_table.c.username == 'ed'
"user".username = :username_1

*Dialect can be chaned as below , 
 print(expression.compile(dialect=postgresql.dialect())) 

*Insert Statement
In : insert_stmt = user_table.insert().values(username='ed', fullname='Ed Jones')
In : conn = engine.connect()
In : result = conn.execute(insert_stmt)

*Multiple Inserts at once 
In : conn.execute(user_table.insert(), [
...:     {'username': 'jack', 'fullname': 'Jack Burger'},
...:     {'username': 'wendy', 'fullname': 'Wendy Weathersmith'}


*Updates:
to round out INSERT and SELECT, this is an UPDATE                |

In : update_stmt = user_table.update().values(fullname="Jack Brown").\
...:                     where(user_table.c.username == "jack")
In : result = conn.execute(update_stmt)


*Deletes;
In : delete_stmt = user_table.delete().where(user_table.c.username == 'jack')
In : result = conn.execute(delete_stmt)

result.rowcoutn gives the nuber of rows that were affected.

*Joins:
Two tables can be joined as below
join_obj = user_table.join(address_table,user_table.c.id == address_table.c.user_id)
ForeignKey allows the join() to figure out the ON clause automatically  so even below would suffice
join_obj = user_table.join(address_table)

to SELECT from a JOIN, use select_from()                         |
In : select_stmt = select([user_table, address_table]).select_from(join_obj)

In SQL, a "subquery" is usually an alias() of a select()  
In : select_alias = select_stmt.alias()
In : print(
...:     select([select_alias.c.username]).
...:         where(select_alias.c.username == 'ed')
...:    )


***ORM ***

SQLAlchemy is a data mapper style ORM like Hibernate



















