Tango With Django
Django commands : 
*make project :   python django-admin.py startproject tango_with_django_project
*Run server : python manage.py runserver --noreload

*render or render_to_response to be used only when a template is used else just use HttpResponse object.
*url mapping from project urls.;y to app specific urls.py is done using include function.

*Create a new ap :  python manage.py startapp rango
Each view takes in at least one argument - a HttpRequest object,Each view must return a HttpResponse object.
The urlpatterns tuple contains a series of calls to the django.conf.urls.url() function, with each call handling a unique mapping.
Sample url mapping below , notice the quotes withininclude  and first arguement
url(r'^rango/', include('rango.urls')),

use below code to find absolute path , never hardcode paths in settings.py file
SETTINGS_DIR = os.path.dirname(__file__);PROJECT_PATH = os.path.join(SETTINGS_DIR, os.pardir);PROJECT_PATH = os.path.abspath(PROJECT_PATH)
Now PROJECT_PATH can be used to setup template , static directories etc like TEMPLATE_PATH = os.path.join(PROJECT_PATH, 'templates').
Static and template dirs are to be placed in the project folder tself
render_to_response Sample :   return render_to_response('rango/index.html', con_dict) #con_dict contains template vars as keys.
STATIC_URL defines the base URL with which your Django applications will find static media files when the server is running.STATIC_URL set to /static/ like in the code example above, static media will be available at http://127.0.0.1:8000/static/ when the server is running.
While STATIC_URL defines the URL to access media via the web server, STATICFILES_DIRS allows you to specify the location of the 
newly created static directory on your local disk.
You can now access such media within your templates as well with  {% load static %} tag declaration which informs Django's template system tat we will b using static media.This allows us to call the static template tag as done in {% static "rango.jpg" %} .the static tag will combine the STATIC_URL with "rango.jpg" so that the rendered HTML looks like the following.

Care should be taken in your templates to ensure that any document type declaration (e.g. <!DOCTYPE html>) you use in your webpages appears in the rendered output on the first line. 

MOdels : 
New models will be synchronised with syncdb - but changes to existing models will not be.
When updating an existing model to your application’s models.py file, you must perform the following steps.
Delete the database.
Recreate the database with the command $ python manage.py syncdb.
Populate the new database with data.
python manage.py syncdb command used to create models on the databse.
python manage.py shell gives shell access with databse objects loaded.
*creating a sample object and saving on DB.
In [2]: from rango.models import Category
In [4]: c = Category(name='Test1')
In [5]: c.save()
In [6]: Category.objects.all()
Out[6]: [<Category: Test1>]

To register the models use below in project urls file.
url(r'^admin/', include(admin.site.urls))

And the below in admin.py file 
from django.contrib import admin
from rango.models import Category, Page
admin.site.register(Category)
admin.site.register(Page)

Note the typo within the admin interface (categorys, not categories). This problem can be fixed by adding a nested Meta class into your model definitions with the verbose_name_plural attribute
class Category(models.Model):
    class Meta:
        verbose_name_plural = "Categories"
    name = models.CharField(unique=True, max_length=128)
	
Setting DJANGO_SETTINGS_MODULE environment modules can give u acccess to models by importing them just like shell command does.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

Page.objects.all() #Returns all rows
Page.objects.filter(id=1) #Returns filtered rows using any field

Admin page for specific models can be changed by creating related modesl in admin.py file for ex:

class PageAdmin(admin.ModelAdmin):
    fields = ['category','title', 'url', 'views'] # tells which fields should be visible and which shuld be not, field sets can also be created to categorize data with headings
    list_display = ('title', 'category', 'url') # displays the data in list format	
	list_filter = ['category'] # applies filter bar

admin.site.register(Page, PageAdmin)
https://docs.djangoproject.com/en/1.5/intro/tutorial02/ -- more data 

*6.1. Basic Workflow: Data Driven Pages
There are five main steps that you must undertake to create a data driven webpage in Django.

First, import the models you wish to use into your application’s views.py file.
Within the view you wish to use, query the model to get the data you want to present.
Pass the results from your model into the template’s context.
Setup your template to present the data to the user in whatever way you wish.
If you have not done so already, map a URL to your view.


*Name ur urls so that u dont have to hardcode ur urls in templates.

*Common code snippet to raise exceptions
def detail(request, poll_id):
    try:
        poll = Poll.objects.get(pk=poll_id)
    except Poll.DoesNotExist:
        raise Http404
    return render(request, 'polls/detail.html', {'poll': poll})
	
Shortcut method for the above
from django.shortcuts import render, get_object_or_404
poll = get_object_or_404(Poll, pk=poll_id)


* you can create a 404.html template in the root of your template directory. The default 404 view will then use that template for all 404 errors when DEBUG is set to False - same thing works for 500.html as well