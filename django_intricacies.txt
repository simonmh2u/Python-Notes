Tango With Django
Django commands : 
*make project :   python django-admin.py startproject tango_with_django_project
*Run server : python manage.py runserver --noreload

*render or render_to_response to be used only when a template is used else just use HttpResponse object.
*url mapping from project urls.;y to app specific urls.py is done using include function.

*Create a new ap :  python manage.py startapp rango
Each view takes in at least one argument - a HttpRequest object,Each view must return a HttpResponse object.
The urlpatterns tuple contains a series of calls to the django.conf.urls.url() function, with each call handling a unique mapping.
Sample url mapping below , notice the quotes withininclude  and first arguement
url(r'^rango/', include('rango.urls')),

use below code to find absolute path , never hardcode paths in settings.py file
SETTINGS_DIR = os.path.dirname(__file__);PROJECT_PATH = os.path.join(SETTINGS_DIR, os.pardir);PROJECT_PATH = os.path.abspath(PROJECT_PATH)
Now PROJECT_PATH can be used to setup template , static directories etc like TEMPLATE_PATH = os.path.join(PROJECT_PATH, 'templates').
Static and template dirs are to be placed in the project folder tself
render_to_response Sample :   return render_to_response('rango/index.html', con_dict) #con_dict contains template vars as keys.
STATIC_URL defines the base URL with which your Django applications will find static media files when the server is running.STATIC_URL set to /static/ like in the code example above, static media will be available at http://127.0.0.1:8000/static/ when the server is running.
While STATIC_URL defines the URL to access media via the web server, STATICFILES_DIRS allows you to specify the location of the 
newly created static directory on your local disk.
You can now access such media within your templates as well with  {% load static %} tag declaration which informs Django's template system tat we will b using static media.This allows us to call the static template tag as done in {% static "rango.jpg" %} .the static tag will combine the STATIC_URL with "rango.jpg" so that the rendered HTML looks like the following.

Care should be taken in your templates to ensure that any document type declaration (e.g. <!DOCTYPE html>) you use in your webpages appears in the rendered output on the first line. 

MOdels : 
New models will be synchronised with syncdb - but changes to existing models will not be.
When updating an existing model to your application’s models.py file, you must perform the following steps.
Delete the database.
Recreate the database with the command $ python manage.py syncdb.
Populate the new database with data.
python manage.py syncdb command used to create models on the databse.
python manage.py shell gives shell access with databse objects loaded.
*creating a sample object and saving on DB.
In [2]: from rango.models import Category
In [4]: c = Category(name='Test1')
In [5]: c.save()
In [6]: Category.objects.all()
Out[6]: [<Category: Test1>]

To register the models use below in project urls file.
url(r'^admin/', include(admin.site.urls))

And the below in admin.py file 
from django.contrib import admin
from rango.models import Category, Page
admin.site.register(Category)
admin.site.register(Page)

Note the typo within the admin interface (categorys, not categories). This problem can be fixed by adding a nested Meta class into your model definitions with the verbose_name_plural attribute
class Category(models.Model):
    class Meta:
        verbose_name_plural = "Categories"
    name = models.CharField(unique=True, max_length=128)
	
Setting DJANGO_SETTINGS_MODULE environment modules can give u acccess to models by importing them just like shell command does.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

Page.objects.all() #Returns all rows
Page.objects.filter(id=1) #Returns filtered rows using any field
Page.objects.get returns just one object - both of the above returns lists
	
Admin page for specific models can be changed by creating related modesl in admin.py file for ex:

class PageAdmin(admin.ModelAdmin):
    fields = ['category','title', 'url', 'views'] # tells which fields should be visible and which shuld be not, field sets can also be created to categorize data with headings
    list_display = ('title', 'category', 'url') # displays the data in list format	
	list_filter = ['category'] # applies filter bar

admin.site.register(Page, PageAdmin)
https://docs.djangoproject.com/en/1.5/intro/tutorial02/ -- more data 

<<<<<<< HEAD
*6.1. Basic Workflow: Data Driven Pages
There are five main steps that you must undertake to create a data driven webpage in Django.

First, import the models you wish to use into your application’s views.py file.
Within the view you wish to use, query the model to get the data you want to present.
Pass the results from your model into the template’s context.
Setup your template to present the data to the user in whatever way you wish.
If you have not done so already, map a URL to your view.


*Name ur urls so that u dont have to hardcode ur urls in templates.

*Common code snippet to raise exceptions
def detail(request, poll_id):
    try:
        poll = Poll.objects.get(pk=poll_id)
    except Poll.DoesNotExist:
        raise Http404
    return render(request, 'polls/detail.html', {'poll': poll})
	
Shortcut method for the above
from django.shortcuts import render, get_object_or_404
poll = get_object_or_404(Poll, pk=poll_id)


* you can create a 404.html template in the root of your template directory. The default 404 view will then use that template for all 404 errors when DEBUG is set to False - same thing works for 500.html as well
=======
The Django template conditional tag - {% if %} - is a really neat way of determining the existence of an object within the template’s context. Try getting into the habit of performing these checks to reduce the scope for potential exceptions that could be raised within your code.

django.conf.urls package has the   patterns, url methods
Finally, a performance note: these regular expressions are compiled the first time the URLconf module is loaded.

Each view is responsible for doing one of two things: returning an HttpResponse object containing the content for the requested page, or raising an exception such as Http404. The rest is up to you.


*The basic steps involved in creating a form and allowing users to enter data via the form is as follows.

    If you haven’t already got one, create a forms.py file within your Django application’s directory to store form-related classes.
    Create a ModelForm class for each model that you wish to represent as a form.
    Customise the forms as you desire.
    Create or update a view to handle the form - including displaying the form, saving the form data, and flagging up errors which may occur when the user enters incorrect data (or no data at all) in the form.
    Create or update a template to display the form.
    Add a urlpattern to map to the new view (if you created a new one).

*Typical form:

class CategoryForm(forms.ModelForm):
    name = forms.CharField(max_length=128, help_text="Please enter the category name.")
    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
    likes = forms.IntegerField(widget=forms.HiddenInput(), initial=0)

    # An inline class to provide additional information on the form.
    class Meta:
        # Provide an association between the ModelForm and a model
        model = Category
Forms are present in from django import forms

To hide certail fields (forms.py)
views = forms.IntegerField(widget = forms.HiddenInput(),initial=0)
template :
		{% for hidden in form.hidden_fields %}
            {{ hidden }}
            {% endfor %}
            
*For each form field that you wish to process, check that a value was retrieved. If something was entered, check what the value was. If it isn’t what you expect, you can then add some logic to fix this issue before reassigning the value in the cleaned_data dictionary for the given field.
lYou must always end the clean() method by returning the reference to the cleaned_data dictionary. If you don’t, you’ll get some really frustrating err

*request.POST is a dictionary-like object that lets you access submitted data by key name.
*you should always return an HttpResponseRedirect after successfully dealing with POST data. This tip isn’t specific to Django; it’s just good Web development practice.
*We are using the reverse() function in the HttpResponseRedirect constructor in this example. This function helps avoid having to hardcode a URL in the view function. 
return HttpResponseRedirect(reverse('polls:results', args=(p.id,))) maps to '/polls/3/results/' where p.id is 3 

Django Authentication : 
We’ll be using the auth application provided as part of a standard Django installation in package django.contrib.auth. 
he Django documentation on User objects states that they are used to allow aspects of the authentication system like access restriction, registration of new user profiles and the association of creators with site content.

The from django.contrib.auth.models import User model comes complete with five primary attributes. They are:   the username for the user account;    the account’s password;    the user’s email address;    the user’s first name; and    the user’s surname.
We can easily add addiotional attribs as below:
class UserProfile(models.Model):
    # This line is required. Links UserProfile to a User model instance.
    user = models.OneToOneField(User)
    website = models.URLField(blank=True)
    picture = models.ImageField(upload_to='profile_images', blank=True)

Needs to be registered in admin.py as admin.site.register(UserProfile)
Saving a form intermediately return the associated model after which we can set or modify the required attributes .ex:
  profile = profile_form.save(commit=False)
            profile.user = user

*To Login a particular user see the below piece of code.
    if request.POST:
        username = request['username']
        password = request['password']
        user = authenticate(username, password) #This does the actual intrinsic athentication and returns user object is auth is successful 
        
login(request,user) is the method actually used to login the user follwed by which  u can redirect to any page u want using below redirect method.
make use of a new class, HttpResponseRedirect. As the name may suggest to you, the response generated by an instance of the HttpResponseRedirect class tells the client’s browser to redirect to the URL you provide as the argument.
from django.contrib.auth.decorators import login_required place this decorator above any view method and it will take care of
restricting access. LOGIN_URL setting in settings.py can be used to redirect the user to login page.
Awesome app for the above :  https://django-registration.readthedocs.org/en/latest/  and https://bitbucket.org/ubernostrum/django-registration/

Index html can be made as below , user us passed in the request context so we can have this conditional display
% if user.is_authenticated %}
<a href="/rango/restricted/">Restricted Page</a><br />
<a href="/rango/logout/">Logout</a><br />
{% else %}
<a href="/rango/register/">Register Here</a><br />
<a href="/rango/login/">Login</a><br />
{% endif %}


**TEMPLATES**

*You should always aim to extract as much reoccurring content for your base templates. While it may be a bit more of a challenge for you to do initially, the time you will save in maintenance of your templates in the future far outweighs the initial overhead. Think about it: would you rather maintain one copy of your markup or multiple copies?
A block is defined as below in django template language.
  {% block body_block %} This is body_block's default content. 	{% endblock %}

You use {% extends 'rango/base.html' %} to extend a particular template. You can override any blck in you sub template ,
if not overridden then the block from base template is displayed.

Variables look like this: {{ variable }}. When the template engine encounters a variable, it evaluates that variable and replaces it with the result
If you use a variable that doesn’t exist, the template system will insert the value of the TEMPLATE_STRING_IF_INVALID setting, which is set to '' (the empty string) by default.

Filters look like this: {{ name|lower }}. This displays the value of the {{ name }} variable after being filtered through the lower filter,
Commonly used filters : {{ value|striptags }},{{ value|length }},{{ value|default:"nothing" }}
Tags look like this: {% tag %}. Tags are more complex than variables: Some create text in the output, some control flow by performing loops or logic, and some load external information into the template to be used by later variables.
Example: 
{% if athlete_list|length > 1 %}
   Team: {% for athlete in athlete_list %} ... {% endfor %}
{% else %}
   Athlete: {{ athlete_list.0.name }}
{% endif %}

Go thru below link of tags
https://docs.djangoproject.com/en/1.5/ref/templates/builtins/#ref-templates-builtins-tags

Comment in template cdode : {# {% if foo %}bar{% else %} #}

You can use as many levels of inheritance as needed. One common way of using inheritance is the following three-level approach:

    Create a base.html template that holds the main look-and-feel of your site.
    Create a base_SECTIONNAME.html template for each “section” of your site. For example, base_news.html, base_sports.html. These templates all extend base.html and include section-specific styles/design.
    Create individual templates for each type of page, such as a news article or blog entry. These templates extend the appropriate section template.
*If you find yourself duplicating content in a number of templates, it probably means you should move that content to a {% block %} in a parent template.
*If you need to get the content of the block from the parent template, the {{ block.super }} variable will do the trick
*Automatic HTML escaping is turned on by default in django templating system and protects us from Cross site scripting (XSS) attack
It can be turned off by 
{% autoescape off %}
    Hello {{ name }}
{% endautoescape %}

*Accessing method calls

Most method calls attached to objects are also available from within templates. This means that templates have access to much more than just class attributes (like field names) and variables passed in from views. 
Ex:
{% for comment in task.comment_set.all %}
    {{ comment }}
{% endfor %}

You cant pass arguements but to methods


*COOKIES and SESSIONS**
The most commonly used way of holding state is through the use of a session ID stored as a cookie on a client’s computer.
A session ID can be considered as a token (a sequence of characters) to identify a unique session within a particular
web application. Instead of storing all kinds of information as cookies on the client (such as usernames, names, passwords...),
only the session ID is stored, which can then be mapped to a data structure on the web server. Within that data structure,
you can store all of the information you require.

django.contrib.sessions.middleware.SessionMiddleware takes care of creating sessions for django
