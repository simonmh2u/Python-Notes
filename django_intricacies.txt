Tango With Django
Django commands : 
*make project :   python django-admin.py startproject tango_with_django_project
*Run server : python manage.py runserver --noreload

*render or render_to_response to be used only when a template is used else just use HttpResponse object.
*url mapping from project urls.;y to app specific urls.py is done using include function.

*Create a new ap :  python manage.py startapp rango
Each view takes in at least one argument - a HttpRequest object,Each view must return a HttpResponse object.
The urlpatterns tuple contains a series of calls to the django.conf.urls.url() function, with each call handling a unique mapping.
Sample url mapping below , notice the quotes withininclude  and first arguement
url(r'^rango/', include('rango.urls')),

use below code to find absolute path , never hardcode paths in settings.py file
SETTINGS_DIR = os.path.dirname(__file__);PROJECT_PATH = os.path.join(SETTINGS_DIR, os.pardir);PROJECT_PATH = os.path.abspath(PROJECT_PATH)
Now PROJECT_PATH can be used to setup template , static directories etc like TEMPLATE_PATH = os.path.join(PROJECT_PATH, 'templates').
Static and template dirs are to be placed in the project folder tself
render_to_response Sample :   return render_to_response('rango/index.html', con_dict) #con_dict contains template vars as keys.
STATIC_URL defines the base URL with which your Django applications will find static media files when the server is running.STATIC_URL set to /static/ like in the code example above, static media will be available at http://127.0.0.1:8000/static/ when the server is running.
While STATIC_URL defines the URL to access media via the web server, STATICFILES_DIRS allows you to specify the location of the 
newly created static directory on your local disk.
You can now access such media within your templates as well with  {% load static %} tag declaration which informs Django's template system tat we will b using static media.This allows us to call the static template tag as done in {% static "rango.jpg" %} .the static tag will combine the STATIC_URL with "rango.jpg" so that the rendered HTML looks like the following.

Care should be taken in your templates to ensure that any document type declaration (e.g. <!DOCTYPE html>) you use in your webpages appears in the rendered output on the first line. 

MOdels : 
New models will be synchronised with syncdb - but changes to existing models will not be.
When updating an existing model to your application’s models.py file, you must perform the following steps.
Delete the database.
Recreate the database with the command $ python manage.py syncdb.
Populate the new database with data.
python manage.py syncdb command used to create models on the databse.
python manage.py shell gives shell access with databse objects loaded.
*creating a sample object and saving on DB.
In [2]: from rango.models import Category
In [4]: c = Category(name='Test1')
In [5]: c.save()
In [6]: Category.objects.all()
Out[6]: [<Category: Test1>]

To register the models use below in project urls file.
url(r'^admin/', include(admin.site.urls))

And the below in admin.py file 
from django.contrib import admin
from rango.models import Category, Page
admin.site.register(Category)
admin.site.register(Page)

Note the typo within the admin interface (categorys, not categories). This problem can be fixed by adding a nested Meta class into your model definitions with the verbose_name_plural attribute
class Category(models.Model):
    class Meta:
        verbose_name_plural = "Categories"
    name = models.CharField(unique=True, max_length=128)
	
Setting DJANGO_SETTINGS_MODULE environment modules can give u acccess to models by importing them just like shell command does.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

Page.objects.all() #Returns all rows
Page.objects.filter(id=1) #Returns filtered rows using any field
Page.objects.get returns just one object - both of the above returns lists
	
Admin page for specific models can be changed by creating related modesl in admin.py file for ex:

class PageAdmin(admin.ModelAdmin):
    fields = ['category','title', 'url', 'views'] # tells which fields should be visible and which shuld be not, field sets can also be created to categorize data with headings
    list_display = ('title', 'category', 'url') # displays the data in list format	
	list_filter = ['category'] # applies filter bar

admin.site.register(Page, PageAdmin)
https://docs.djangoproject.com/en/1.5/intro/tutorial02/ -- more data 

The Django template conditional tag - {% if %} - is a really neat way of determining the existence of an object within the template’s context. Try getting into the habit of performing these checks to reduce the scope for potential exceptions that could be raised within your code.

django.conf.urls package has the   patterns, url methods
Finally, a performance note: these regular expressions are compiled the first time the URLconf module is loaded.

Each view is responsible for doing one of two things: returning an HttpResponse object containing the content for the requested page, or raising an exception such as Http404. The rest is up to you.


*The basic steps involved in creating a form and allowing users to enter data via the form is as follows.

    If you haven’t already got one, create a forms.py file within your Django application’s directory to store form-related classes.
    Create a ModelForm class for each model that you wish to represent as a form.
    Customise the forms as you desire.
    Create or update a view to handle the form - including displaying the form, saving the form data, and flagging up errors which may occur when the user enters incorrect data (or no data at all) in the form.
    Create or update a template to display the form.
    Add a urlpattern to map to the new view (if you created a new one).

*Typical form:

class CategoryForm(forms.ModelForm):
    name = forms.CharField(max_length=128, help_text="Please enter the category name.")
    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
    likes = forms.IntegerField(widget=forms.HiddenInput(), initial=0)

    # An inline class to provide additional information on the form.
    class Meta:
        # Provide an association between the ModelForm and a model
        model = Category
Forms are present in from django import forms

To hide certail fields (forms.py)
views = forms.IntegerField(widget = forms.HiddenInput(),initial=0)
template :
		{% for hidden in form.hidden_fields %}
            {{ hidden }}
            {% endfor %}
            
*For each form field that you wish to process, check that a value was retrieved. If something was entered, check what the value was. If it isn’t what you expect, you can then add some logic to fix this issue before reassigning the value in the cleaned_data dictionary for the given field.
lYou must always end the clean() method by returning the reference to the cleaned_data dictionary. If you don’t, you’ll get some really frustrating err

