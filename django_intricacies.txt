Tango With Django
Django commands : 
*make project :   python django-admin.py startproject tango_with_django_project
*Run server : python manage.py runserver --noreload

*render or render_to_response to be used only when a template is used else just use HttpResponse object.
*url mapping from project urls.;y to app specific urls.py is done using include function.

*Create a new ap :  python manage.py startapp rango
Each view takes in at least one argument - a HttpRequest object,Each view must return a HttpResponse object.
The urlpatterns tuple contains a series of calls to the django.conf.urls.url() function, with each call handling a unique mapping.
Sample url mapping below , notice the quotes withininclude  and first arguement
url(r'^rango/', include('rango.urls')),

use below code to find absolute path , never hardcode paths in settings.py file
SETTINGS_DIR = os.path.dirname(__file__);PROJECT_PATH = os.path.join(SETTINGS_DIR, os.pardir);PROJECT_PATH = os.path.abspath(PROJECT_PATH)
Now PROJECT_PATH can be used to setup template , static directories etc like TEMPLATE_PATH = os.path.join(PROJECT_PATH, 'templates').
Static and template dirs are to be placed in the project folder tself
render_to_response Sample :   return render_to_response('rango/index.html', con_dict) #con_dict contains template vars as keys.
STATIC_URL defines the base URL with which your Django applications will find static media files when the server is running.STATIC_URL set to /static/ like in the code example above, static media will be available at http://127.0.0.1:8000/static/ when the server is running.
While STATIC_URL defines the URL to access media via the web server, STATICFILES_DIRS allows you to specify the location of the 
newly created static directory on your local disk.
You can now access such media within your templates as well with  {% load static %} tag declaration which informs Django's template system tat we will b using static media.This allows us to call the static template tag as done in {% static "rango.jpg" %} .the static tag will combine the STATIC_URL with "rango.jpg" so that the rendered HTML looks like the following.

Care should be taken in your templates to ensure that any document type declaration (e.g. <!DOCTYPE html>) you use in your webpages appears in the rendered output on the first line. 

MOdels : 
New models will be synchronised with syncdb - but changes to existing models will not be.
When updating an existing model to your application’s models.py file, you must perform the following steps.
Delete the database.
Recreate the database with the command $ python manage.py syncdb.
Populate the new database with data.
python manage.py syncdb command used to create models on the databse.
python manage.py shell gives shell access with databse objects loaded.
*creating a sample object and saving on DB.
In [2]: from rango.models import Category
In [4]: c = Category(name='Test1')
In [5]: c.save()
In [6]: Category.objects.all()
Out[6]: [<Category: Test1>]

To register the models use below in project urls file.
url(r'^admin/', include(admin.site.urls))

And the below in admin.py file 
from django.contrib import admin
from rango.models import Category, Page
admin.site.register(Category)
admin.site.register(Page)

Note the typo within the admin interface (categorys, not categories). This problem can be fixed by adding a nested Meta class into your model definitions with the verbose_name_plural attribute
class Category(models.Model):
    class Meta:
        verbose_name_plural = "Categories"
    name = models.CharField(unique=True, max_length=128)
	
Setting DJANGO_SETTINGS_MODULE environment modules can give u acccess to models by importing them just like shell command does.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

Page.objects.all() #Returns all rows
Page.objects.filter(id=1) #Returns filtered rows using any field
Page.objects.get returns just one object - both of the above returns lists
	
Admin page for specific models can be changed by creating related modesl in admin.py file for ex:

class PageAdmin(admin.ModelAdmin):
    fields = ['category','title', 'url', 'views'] # tells which fields should be visible and which shuld be not, field sets can also be created to categorize data with headings
    list_display = ('title', 'category', 'url') # displays the data in list format	
	list_filter = ['category'] # applies filter bar

admin.site.register(Page, PageAdmin)
https://docs.djangoproject.com/en/1.5/intro/tutorial02/ -- more data 

<<<<<<< HEAD
*6.1. Basic Workflow: Data Driven Pages
There are five main steps that you must undertake to create a data driven webpage in Django.

First, import the models you wish to use into your application’s views.py file.
Within the view you wish to use, query the model to get the data you want to present.
Pass the results from your model into the template’s context.
Setup your template to present the data to the user in whatever way you wish.
If you have not done so already, map a URL to your view.


*Name ur urls so that u dont have to hardcode ur urls in templates.

*Common code snippet to raise exceptions
def detail(request, poll_id):
    try:
        poll = Poll.objects.get(pk=poll_id)
    except Poll.DoesNotExist:
        raise Http404
    return render(request, 'polls/detail.html', {'poll': poll})
	
Shortcut method for the above
from django.shortcuts import render, get_object_or_404
poll = get_object_or_404(Poll, pk=poll_id)


* you can create a 404.html template in the root of your template directory. The default 404 view will then use that template for all 404 errors when DEBUG is set to False - same thing works for 500.html as well
=======
The Django template conditional tag - {% if %} - is a really neat way of determining the existence of an object within the template’s context. Try getting into the habit of performing these checks to reduce the scope for potential exceptions that could be raised within your code.

django.conf.urls package has the   patterns, url methods
Finally, a performance note: these regular expressions are compiled the first time the URLconf module is loaded.

Each view is responsible for doing one of two things: returning an HttpResponse object containing the content for the requested page, or raising an exception such as Http404. The rest is up to you.


*The basic steps involved in creating a form and allowing users to enter data via the form is as follows.

    If you haven’t already got one, create a forms.py file within your Django application’s directory to store form-related classes.
    Create a ModelForm class for each model that you wish to represent as a form.
    Customise the forms as you desire.
    Create or update a view to handle the form - including displaying the form, saving the form data, and flagging up errors which may occur when the user enters incorrect data (or no data at all) in the form.
    Create or update a template to display the form.
    Add a urlpattern to map to the new view (if you created a new one).

*Typical form:

class CategoryForm(forms.ModelForm):
    name = forms.CharField(max_length=128, help_text="Please enter the category name.")
    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
    likes = forms.IntegerField(widget=forms.HiddenInput(), initial=0)

    # An inline class to provide additional information on the form.
    class Meta:
        # Provide an association between the ModelForm and a model
        model = Category
Forms are present in from django import forms

To hide certail fields (forms.py)
views = forms.IntegerField(widget = forms.HiddenInput(),initial=0)
template :
		{% for hidden in form.hidden_fields %}
            {{ hidden }}
            {% endfor %}
            
*For each form field that you wish to process, check that a value was retrieved. If something was entered, check what the value was. If it isn’t what you expect, you can then add some logic to fix this issue before reassigning the value in the cleaned_data dictionary for the given field.
lYou must always end the clean() method by returning the reference to the cleaned_data dictionary. If you don’t, you’ll get some really frustrating err

*request.POST is a dictionary-like object that lets you access submitted data by key name.
*you should always return an HttpResponseRedirect after successfully dealing with POST data. This tip isn’t specific to Django; it’s just good Web development practice.
*We are using the reverse() function in the HttpResponseRedirect constructor in this example. This function helps avoid having to hardcode a URL in the view function. 
return HttpResponseRedirect(reverse('polls:results', args=(p.id,))) maps to '/polls/3/results/' where p.id is 3 

Django Authentication : 
We’ll be using the auth application provided as part of a standard Django installation in package django.contrib.auth. 
he Django documentation on User objects states that they are used to allow aspects of the authentication system like access restriction, registration of new user profiles and the association of creators with site content.

The from django.contrib.auth.models import User model comes complete with five primary attributes. They are:   the username for the user account;    the account’s password;    the user’s email address;    the user’s first name; and    the user’s surname.
We can easily add addiotional attribs as below:
class UserProfile(models.Model):
    # This line is required. Links UserProfile to a User model instance.
    user = models.OneToOneField(User)
    website = models.URLField(blank=True)
    picture = models.ImageField(upload_to='profile_images', blank=True)

Needs to be registered in admin.py as admin.site.register(UserProfile)
Saving a form intermediately return the associated model after which we can set or modify the required attributes .ex:
  profile = profile_form.save(commit=False)
            profile.user = user

*To Login a particular user see the below piece of code.
    if request.POST:
        username = request['username']
        password = request['password']
        user = authenticate(username, password) #This does the actual intrinsic athentication and returns user object is auth is successful 
        
login(request,user) is the method actually used to login the user follwed by which  u can redirect to any page u want using below redirect method.
make use of a new class, HttpResponseRedirect. As the name may suggest to you, the response generated by an instance of the HttpResponseRedirect class tells the client’s browser to redirect to the URL you provide as the argument.
from django.contrib.auth.decorators import login_required place this decorator above any view method and it will take care of
restricting access. LOGIN_URL setting in settings.py can be used to redirect the user to login page.
Awesome app for the above :  https://django-registration.readthedocs.org/en/latest/  and https://bitbucket.org/ubernostrum/django-registration/

Index html can be made as below , user us passed in the request context so we can have this conditional display
% if user.is_authenticated %}
<a href="/rango/restricted/">Restricted Page</a><br />
<a href="/rango/logout/">Logout</a><br />
{% else %}
<a href="/rango/register/">Register Here</a><br />
<a href="/rango/login/">Login</a><br />
{% endif %}


**TEMPLATES**

*You should always aim to extract as much reoccurring content for your base templates. While it may be a bit more of a challenge for you to do initially, the time you will save in maintenance of your templates in the future far outweighs the initial overhead. Think about it: would you rather maintain one copy of your markup or multiple copies?
A block is defined as below in django template language.
  {% block body_block %} This is body_block's default content. 	{% endblock %}

You use {% extends 'rango/base.html' %} to extend a particular template. You can override any blck in you sub template ,
if not overridden then the block from base template is displayed.

Variables look like this: {{ variable }}. When the template engine encounters a variable, it evaluates that variable and replaces it with the result
If you use a variable that doesn’t exist, the template system will insert the value of the TEMPLATE_STRING_IF_INVALID setting, which is set to '' (the empty string) by default.

Filters look like this: {{ name|lower }}. This displays the value of the {{ name }} variable after being filtered through the lower filter,
Commonly used filters : {{ value|striptags }},{{ value|length }},{{ value|default:"nothing" }}
Tags look like this: {% tag %}. Tags are more complex than variables: Some create text in the output, some control flow by performing loops or logic, and some load external information into the template to be used by later variables.
Example: 
{% if athlete_list|length > 1 %}
   Team: {% for athlete in athlete_list %} ... {% endfor %}
{% else %}
   Athlete: {{ athlete_list.0.name }}
{% endif %}

Go thru below link of tags
https://docs.djangoproject.com/en/1.5/ref/templates/builtins/#ref-templates-builtins-tags

Comment in template cdode : {# {% if foo %}bar{% else %} #}

You can use as many levels of inheritance as needed. One common way of using inheritance is the following three-level approach:

    Create a base.html template that holds the main look-and-feel of your site.
    Create a base_SECTIONNAME.html template for each “section” of your site. For example, base_news.html, base_sports.html. These templates all extend base.html and include section-specific styles/design.
    Create individual templates for each type of page, such as a news article or blog entry. These templates extend the appropriate section template.
*If you find yourself duplicating content in a number of templates, it probably means you should move that content to a {% block %} in a parent template.
*If you need to get the content of the block from the parent template, the {{ block.super }} variable will do the trick
*Automatic HTML escaping is turned on by default in django templating system and protects us from Cross site scripting (XSS) attack
It can be turned off by 
{% autoescape off %}
    Hello {{ name }}
{% endautoescape %}

*Accessing method calls

Most method calls attached to objects are also available from within templates. This means that templates have access to much more than just class attributes (like field names) and variables passed in from views. 
Ex:
{% for comment in task.comment_set.all %}
    {{ comment }}
{% endfor %}

You cant pass arguements but to methods


*COOKIES and SESSIONS**
The most commonly used way of holding state is through the use of a session ID stored as a cookie on a client’s computer.
A session ID can be considered as a token (a sequence of characters) to identify a unique session within a particular
web application. Instead of storing all kinds of information as cookies on the client (such as usernames, names, passwords...),
only the session ID is stored, which can then be mapped to a data structure on the web server. Within that data structure,
you can store all of the information you require.

django.contrib.sessions.middleware.SessionMiddleware takes care of creating sessions for django
browser-length sessions expire when the user closes his or her browser; and
persistent sessions can last over several browser instances - expiring at a time of your choice. This could be half an hour, or even as far as a month in the future.
Add the variable SESSION_EXPIRE_AT_BROWSER_CLOSE, setting it to True.

**
If client-side cookies are the right approach for you then work through the following steps:

    You must first perform a check to see if the cookie you want exists. This can be done by checking the request parameter. The request.COOKIES.has_key('<cookie_name>') function returns a boolean value indicating whether a cookie <cookie_name> exists on the client’s computer or not.
    If the cookie exists, you can then retrieve its value - again via the request parameter - with request.COOKIES[]. The COOKIES attribute is exposed as a dictionary, so pass the name of the cookie you wish to retrieve as a string between the square brackets. Remember, cookies are all returned as strings, regardless of what they contain. You must therefore be prepared to cast to the correct type.
    If the cookie doesn’t exist, or you wish to update the cookie, pass the value you wish to save to the response you generate. response.set_cookie('<cookie_name>', value) is the function you call, where two parameters are supplied: the name of the cookie, and the value you wish to set it to.

If you need more secure cookies, then use session based cookies:

    Make sure that MIDDLEWARE_CLASSES in settings.py contains ‘django.contrib.sessions.middleware.SessionMiddleware’.
    Configure your session backend SESSION_ENGINE. See the official Django Documentation on Sessions for the various backend configurations.
    Check to see if the cookie exists via requests.sessions.get()
    Update or set the cookie via the session dictionary, requests.session['<cookie_name>']

Sample Code ; 
    if request.session.get('last_visit'):
                
        visits = request.session.get('visits', 0)
        request.session['visits'] = visits + 1
        request.session['last_visit'] = str(datetime.now())
    else:
        # The get returns None, and the session does not have a value for the last visit.
        request.session['last_visit'] = str(datetime.now())
        request.session['visits'] = 1
        
*TWITTER BOOTSTRAP **

The reason to add jquery and bootstrap.js files at the end in body is llso that the page can load up faster. The browser concentrates on rendering the elements of the webpage, and once this has been completed, the JavaScript files are loaded.

    

*python manage.py dumpdata article --indent=4 >article.json this command dumps the artilce table in jsn format.
*python manage.py sqlclear article | python manage.py dbshell this command will clear the article table
*python manage.py loaddata article.json will load data
*Article.objects.filter(title__contains="simon") will return objects that match the title simon.

Typical Ajax call looks like below : 

$(function(){

    $('#search').keyup(function() {
    
        $.ajax({
            type: "POST",
            url: "/articles/search/",
            data: { 
                'search_text' : $('#search').val(),
                'csrfmiddlewaretoken' : $("input[name=csrfmiddlewaretoken]").val()
            },
            success: searchSuccess,
            dataType: 'html'
        });
        
    });

});

function searchSuccess(data, textStatus, jqXHR)
{
    $('#search-results').html(data);
}

Here the method search in views returns the the article objects mathcin the search_text.
This is erndered in its own html file. the rendered ouput in html is displayed by searchSuccess method above.

Webserveices with Tasty Pie.
Tasty comes by default only for JSON , u need to install lxml and defusedxml to support xml .

from tastypie.resources import ModelResource -- this will be used as base class to create web resource.
class ArticleResource(ModelResource):
    class Meta:
        queryset = Article.objects.all()   # data of article object
        resource_name = 'article'			# url resource name
        filtering = { "title" : "contains" }
        
In urls.py create an instance of above resource
art = ArticleResource()
url(r'^api/', include(art.urls)) # the .urs comes from the base class i.e ModelResource.
SyncDB to be done after this step for adding indexes etc on DB.
Web Service can be accessed at /api/article/?format=json.
resource_uri field aso gets generatd for the data which can be used to extract indivisual resources based on id
filtering can be used for specific filtering on specific fields
for example to extract the article field for which the title contais simon the below URL can be used
/api/article/?format=json&title__contains=simon


Data Migrations using south
manage.py schemamigration article --initial #This will detect the models and create an initial snapshot
manage.py schemamigration article --auto # Detech further changes if any like addition of new models etc and  and take snapshot.
Each snapshot creates a python file with migration number like 0001 , 0002 etc. Each of this file has a forward and a backwod method,
which defines the next step for ex forward for intiial migration would be create table command and for backword method the definition 
would be drop table command.
python manage.py migrate article will actually apply all the migration snapshots we created above.
south_migrationhistiry table has all the history of migrations

python migrate artile 0002 -- this will revert the schema back snapshot 0002.
To delete any specific migrateion just delete the respective .py files tats all

For example if u wanna convert a model which just has name and u wann use fname and lname now u need to add the new fields
without removing the old field and create an --auto migration.

Next create a data migration snapshot as below
python manage.py datamigration artilce convert_names # this wil create a convert_names.py file with forward and backward methods.
Where you need to write the data migration code.

We then need to take out the name filed from models and create a schema migration upto this ipoint.

General Notes :
--auto looks at the previous migration, works out what’s changed, and creates a migration which applies the differences 
- for example, if you add a field to a model, --auto will notice this, and make a migration which creates a new column for 
that field on its model’s table.
However, you’ll notice that --auto needs a previous migration - our new app doesn’t have one. Instead, 
in this case, we need to use --initial, which will create tables and indexes for all of the models in the app;
 it’s what you use first, much like syncdb, and --auto is then used afterwards for each change.
 
*manage.py schemamigration southtut --auto --update # this can be used when u need to amedn the existing migration 
which has already been applied.What south does is tat it reverts the migrations to prevous and then creates the new 
snapshot with the changes .
./manage.py migrate --list -- Lists all migrations

  ./manage.py convert_to_south myapp -- used to convert existing app to souths

*Full Text Search using Haystack and Whoosh

necesssary configs:
WHOOSH_INDEX = os.path.join(PROJECT_DIRECTORY,'whoosh/')
HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
        'PATH': WHOOSH_INDEX,
    },
}

http://django-haystack.readthedocs.org/en/v2.2.0/tutorial.html

Views : 
def search_titles(request):
    articles = SearchQuerySet().autocomplete(content_auto=request.POST.get('search_text', ''))  

Main Class setup in search_indices.py
class ArticleIndex(indexes.SearchIndex, indexes.Indexable):   #Bases that enable to search and index respectively.
    text = indexes.CharField(document=True, use_template=True) #document is True is mandatory
    pub_date = indexes.DateTimeField(model_attr='pub_date')    #mapping fiels to actual attributes in model article
    content_auto = indexes.EdgeNgramField(model_attr='title')  #mapping fiels to actual attributes in model article
    
    def get_model(self):   #Overding this method and return the model
        return Article

    def index_queryset(self, using=None):
        """Used when the entire index for model is updated."""
        return self.get_model().objects.all()

To build a SearchIndex, all that’s necessary is to subclass both indexes.
SearchIndex & indexes.Indexable, define the fields you want to store data with and define a get_model method.


***CLASS BASED VIEWS***
At its core, a class-based view allows you to respond to different HTTP request methods with different class instance methods, instead of with conditionally branching code inside a single view function
Allows us to use mixins hence reusability factor increased.
from django.views.generic import View # command resting pace for generic views.
Typical Generic View :
class MyView(View):
    def get(self, request):
        # <view logic>
        return HttpResponse('result')
        
Typical URL conf 
url(r'^about/', MyView.as_view()),
The as_view entry point creates an instance of your class and calls its dispatch() method. dispatch looks at the request to determine whether it is a GET,POSt etc.
Note also that you can only inherit from one generic view - that is, only one parent class may inherit from View and the rest (if any) should be mixins. T

Decorators can be applied within the url conf as below:
(r'^about/', login_required(TemplateView.as_view(template_name="secret.html"))),
A method on a class isn’t quite the same as a standalone function, so you can’t just apply a function decorator to the method – 
you need to transform it into a method decorator first. 
The method_decorator decorator transforms a function decorator into a method decorator so that 
it can be used on an instance method. For example:
 
 @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
 
Generic View example

from django.views.generic import ListView
from books.models import Book

class AcmeBookList(ListView):

    context_object_name = 'book_list'				#object name in template
    queryset = Book.objects.filter(publisher__name='Acme Publishing') # criteria based on which objects are retuned in queyset
    template_name = 'books/acme_list.html'	#template name
    
You can even use model = Book incase you wanted queryset to be Book.objects.all
ListView has a get_queryset() method we can override. Previously, it has just been returning the value of 
the queryset attribute, but now we can add more logic.
urlpatterns = patterns('',
    (r'^books/([\w-]+)/$', PublisherBookList.as_view()),
)

def get_queryset(self):
        self.publisher = get_object_or_404(Publisher, name=self.args[0]) #Here args[0] is the arguement pass above in urlconf
        return Book.objects.filter(publisher=self.publisher)


*Processing Forms with Clas Based Views*
